---
tags: 演算法
---
# 動態規劃
## 介紹
動態規劃便是將問題拆分成子問題，並先解決子問題後再去將他拼湊再一起。

以下分成幾點進行介紹
1.與貪婪與分而治之差別
2.想法
3.網格
4.程式
5.結論

---
## 與貪婪與分而治之差別

### 動態規劃與分而治之差別
而分而治之跟動態的差別再於，分而治之需要在計算每個子問題的時候都進行計算，而動態規劃則更多是將範圍較大的子問題與之前運算過的的範圍較小的子問題運算結果進行比較。

### 動態規劃與貪婪算法之差異
雖然兩者都是將問題劃分成小的子問題，但是仍有一些差異

- 動態規劃是為了解決分而治之過於消耗記憶體而產生，他將運算過的保存下來避免二度計算，當遇到有大量重複的子問題時，可以直接使用前面的解
- 貪婪算法的每一次操作都會對結果產生影響，而動態規劃不會，貪婪算法對於每個子問題都必須做出選擇，不能後退。動態規劃則會根據以前的選擇結果來對當前結果進行選擇，有後退功能(可推翻之前所得到的結果)。
- 動態規劃主要運用於二維或三維問題，而貪婪算法一般是一維問題
- 貪婪算法結果是最優近似解，而動態規劃是最優解

---

## 想法
我們一樣以背包問題進行示範，逐步增加背包重量，長出當次循環中最大價值的組合方式，查找最優解。

假設背包最大容量為4磅
- 音響 4磅3000美元
- 電腦 3磅2000美元
- 吉他 1磅1500美元
解法：
1.先劃出表格
2.再去逐步去計算他

- 第一步：畫出表格
|  |1 |2 |3|4
| :---: | :---: | :---: |:---:|:---:|
| 吉他|
|音響|
|電腦|

- 第二步：從吉他開始計算
|  |1 |2 |3|4
| :---: | :---: | :---: |:---:|:---:|
| 吉他|1500|1500|1500|1500
|音響
|電腦|

在這一步驟中我們知道吉他為1磅，所以我們從1磅的位置開始填寫，每一個格子都是當前最佳解

- 第三步：計算音響
|  |1 |2 |3|4
| :---: | :---: | :---: |:---:|:---:|
| 吉他|1500|1500|1500|1500
|音響|1500|1500|1500|3000|
|電腦

在4磅的位置我們可以發現此時音響價格是比吉他還要高的所以我們進行替換

- 第四步：計算電腦
|  |1 |2 |3|4
| :---: | :---: | :---: |:---:|:---:|
| 吉他|1500|1500|1500|1500
|音響|1500|1500|1500|3000|
|電腦|1500|1500|2000|3500

在這一步驟中，在3磅時，我們發現了電腦價格優於吉他，於是我們進行更新。在4磅時，吉他加上電腦優於音響的價格。

- 最後結果：吉他+電腦=3500
- 小結論
1.這個例子的計算方法便是動態規劃的演算方式。
2.在這個例子中也將它可後退修改的特性展現出來。
3.沿著向下走時，最大價值不會降低，每次執行都會存最大價值
4.行的排序方式並會影響最終結果
5.根據新商品的增加可能要考慮更加細膩的方法，並調整結構，如由1磅調整為0.5磅。
6.考慮拿走商品的一部分時無法使用動態規劃，使用動態規劃時，只能選擇拿與不拿，無法判斷要拿走多少%，此為**動態規劃侷限性**。如果要考慮這點，可以換成使用貪婪算法。
7.僅在格子都是離散不互相依賴時才能使用。
8.最優解可能導致背包沒裝滿。

---
## 網格
### 繪製網格
網格便如同一個表格，在繪製前需要考慮以下幾個問題
1.每一個格子的值是多少
2.如何劃分成子問題
3.網格的座標是甚麼

在下面我們以找出兩個單字FISH、HISH相似點作為範例。也就是去查找他的最長公共子有多少個。
>最長公共子：兩個字串中有多少個一樣的字母，可用於判斷兩文件重複性或相關性
在畫網格前可以我們先去思考每一格的值，在警慎思考後我發現我們需要找尋的是字串Str，所以我把這兩個字拆開成字母Char，並將fis、his畫成兩個子問題，網格座標便是兩個單字

### 網格填充
接下來進行填充網格

第一步：繪製
|  |H |I |S|H
| :---: | :---: | :---: |:---:|:---:|
| F|
|I|
|S|
|H|

第二步：填充第一排
|  |H |I |S|H
| :---: | :---: | :---: |:---:|:---:|
| F|0|0|0|0|
|I|
|S|
|H|
找出同XY軸字母是否相同，相同填1，不同填0

第三步：依此類推直到做完
|  |H |I |S|H
| :---: | :---: | :---: |:---:|:---:|
| F|0|0|0|0|
|I|0|1|0|0
|S|0|0|2|0
|H|1|0|0|3

由此可知他們的最長公共子有3個

我們依此來寫個大略的程式吧~
```python=
if word_a[i]==word_b[j]: #兩字母相同
    cell[i][j]=cell[i-1][j-1]+1
else:                    #兩字母不同
    cell[i][j]=max(cell[i-1][j-1],cell[i][j-1])
```
---
## 程式
```python=
#設置
#因為座標(0,0)是空的所以[0]無用
w = [0, 1, 4, 3, 1]   #n個物體的重量(w[0]無用)
p = [0, 1500, 3000, 2000, 2000]   #n個物體的價值(p[0]無用)
n = len(w) - 1   #計算n的個數
m = 4   #背包的載重量

x = []   #裝入背包的物體，元素為True時，對應物體被裝入(x[0]無用)
v = 0
#optp[i][j]表示在前i個物體中，能夠裝入載重量為j的背包中的物體的最大價值
optp = [[0 for col in range(m + 1)] for raw in range(n + 1)]
#optp 相當於做了一個n*m的全零矩陣，n行為物件，m列為自背包載重量

def knapsack_dynamic(w, p, n, m, x):
    #計算optp[i][j]
    for i in range(1, n + 1):       # 物品一件件丟進來
        for j in range(1, m + 1):   # j為子背包的目前能裝的量，尋找能夠裝得下的包包
            if (j >= w[i]):         # 當物品的重量小於背包能夠承受的重量的時候，才考慮能不能放進去
                optp[i][j] = max(optp[i - 1][j], optp[i - 1][j - w[i]] + p[i])
                # optp[i - 1][j]是上一個單元的值， optp[i - 1][j - w[i]]為剩下空間的值
            else:
                optp[i][j] = optp[i - 1][j]

    #到推裝入背包裡的東西,尋找改變的地方，從最後結果開始逆推回來
    j = m
    for i in range(n, 0, -1):
        if optp[i][j] > optp[i - 1][j]:
            x.append(i)
            j = j - w[i]

    #將最大值丟回去，也就是表格最後一行一列的位置
    v = optp[n][m]
    return v

print ('最大值為：' + str(knapsack_dynamic(w, p, n, m, x)))
print ('物品的索引：',x)
```
結果：
```python=
最大值為：4000
物品的索引： [4, 3]
```
因為我們的結果是從後面推回來所以索引值是4、3，而不是3、4，其實這是沒差的。

---
## 結論
1.需要在給定約束條件下優化某種指標時，動態規劃很有用。
2.問題可分解為離散子問題時，可使用動態規劃來解決。
3.每種動態規劃解決方案都設計網格。
4.單元格中的值通常就是你要優化的值。
5.每格單元格都是一個子問題，因此你需要考慮如何將問題分解為子問題。
6.沒有放之四海皆準的計算動態規劃解決方案的公式。

---