---
tags: 演算法
---
# 散列表

## 散列函數
我們先從散列函數講起，他基本上就是你給他一個值他就會回傳一個固定的值給你，像是你跟他說你要蘋果，他就跟你說20元一顆。

在創建散列表時，我們需要先給他一個空的表格
```python=
dic={}
```
接下來才能把資料加入進去，假如你把蘋果的價錢放到3這個位置，下次你呼喚蘋果時，他就會值將去3這個位置取值給你。
```python=
book={}
book["apple"]=0.67
book["milk"]=1.49
print("book")
>>>{'apple':0.67,'milk':1.49}
print(book["apple"])
>>>0.67
```
---
## 應用範例

散列表常應用於：
- 創建映射
- 緩存\記住數據
- 防止重複
像是電話簿和紀錄ip位置
以下舉一個電話簿的例子
```python=
phone_book={}
phone_book["jenny"]=123456
phone_nook["andy"]=123445
print("andy")
>>>123445
```
如果你需要andy的電話號碼你只需要填入他的名子即可拿到他的號碼

---
投票驗證示範
下面的例子是為了示範投票時，該投票者是否已經投過了
```python=
vote={}
def check_vote(name):
	if vote.get(name):
		print("勾勾")
	else:
		vote.setdefault(name,name)
		print("xx")
while True:
	name=input("輸入名子")
	check_vote(name)
```
我們將投過的姓名存入vote{}中，下次確認時就可以知道他已經投過了

---
## 衝突
現在你有26格，你剛好依照a-z來將你的資料排序丟進取，在這時候你要讀取apple的價錢時，你會發現他跟avocado價錢一樣，但實際上是不一樣的，這樣就換產生衝突。這時候你就會需要用到鍊表來輔助，將每個水果設定在鍊表每一個位置他們分別有自己的價錢。但如果鍊很長的話就會影響到整個程序的時間，所以散列的設計與規劃是很重要的。

---
## 性能

每一個演算法都有他的速度，然而散列表的大O時間又是多少呢?
散列表平均時間為O(1)，這代表著他無論有多少資料，找一個元素所花費的時間都相同，在平均情況下他的確是很大的。在最糟狀況下他為O(n)線性時間，這是恨慢的，接下來將他與陣列和鍊表比較一下~

在平均時間下散列表的查找速度和陣列一樣快，刪除跟插入跟鍊表一樣快，因此他具有兩者的優點。在最糟情況下，各種操作他都很慢，因此避免衝突是很重要的，避免衝突有兩種方法：

- 較低的填裝因子
- 良好的散列函數

---
### 填裝因子
填裝因子算法：散列表中的元素數/位置總數
例如我有3筆數據要存到空間有10的散列表中，填裝因子便是0.3。
假設你要填裝100個物品，你有100個位置，那麼最佳狀況便是每個物品都有自己的位置，因子=1，但如果位置只有50呢?因子則為2。不可能讓每個物品都有一個位置，因為沒有足夠的位置。所以當田莊因子開始擴大時，我們就需要再散列表中增加位置，這被稱為**調整長度(resizing)**，根據經驗法則，一但填裝因子大於0.7就需調整散列長度。

調整長度會影響工作時間嗎?答案是會的，但平均而言，即便考慮調整長度所需時間，散列表所需時間依舊為O(1)

---
### 良好的散列函數

- 好的函數讓陣列中的值均勻分布
- 壞的函數讓數值堆在一起，導致大量衝突
- EX.SHA函數

---