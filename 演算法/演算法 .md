---
tags: 演算法
---
# 演算法

----

任何程式都可以是算法的一種，算法有兩個工用，第一個是可使程式可視化，第二個是執行速率加快

---

## 二分查找

----

當要你在1~100猜一個數時，你會怎麼猜，甚麼方法可以最快的到答案?

----

1.隨便猜

2.小的開始

3.大的開始

4.重中間猜

----

答案是重中間開始

----

當答案是100時，你從1開始猜，猜到100，你總共需要猜100

----

而當從中間開始猜呢?

----

你每次所要找的範圍都會減少一半

----

這就是二分查找法

----

用二分查找法最多只需要log2⁡n步驟幾可找到

----

這樣續行時間是不是就減少了呢?

----

給大家示範一下二分查詢法的程式碼吧!

```python=
def binary_search(list,item):
	low=0
	high=len(list)-1

	while low <= high:
		mid=(low+high)/2
		guess=list[mid]
		if guess == item:
			return mid
		if guess > item:
			high=mid-1
		else:
			low=mid+1
	return None

my_list=[1,3,4,5,8,9]

print(binary_search(my_list,3))
print(binary_search(my_list,-3))

```

---

## 大O表示法

----

大O表示法指出一個算法的速度有多快，而運行時間就是指一個程式需要多少時間來完成程式的運行

----

一些常見的大O運行時間：

----

對數時間
O(log n)
例如二分查找

----

線性時間
O(n)
例如簡單查找

----

O(n x nlogn)
例如快速排序法

----

O(n^2)
例如選擇排序法

----

O(N!)
例如旅行路途問題
P.s非常慢的方法

----

大O排序法比較
![大O排序法比較](https://images2017.cnblogs.com/blog/771172/201708/771172-20170826210224918-1742491196.png)

---

## 選擇排序法

----

首先介紹兩個觀念
陣列跟鍊表

----

陣列根鍊表都是拿來處存資料用
但兩者卻在處存與讀取上有著不同的特性

----

陣列在存放資料時為延續性不中斷的處存方法。

----

以處存資料來說，當你的櫃子有1~10編號的格子，當[1、3、4、5、7]的位置都填滿時，你有3個單位的資料需要填進去，你不能分開來塞，因為陣列的連續性，你必須將他放在一起，所以你只能放在[8、9、10]這三個位置之中。

----

鍊表則是不需要連續性的放在一起，你隨便放都可以

----

在剛剛的例子中[1、3、4、5、7]都有放東西了，你要去存放資料有3個單位，因為他是鍊表的關係，你可以放在[2、6、8]這個位置

----

那陣列跟鍊表哪個好用呢?

----

這依樣要看你要用在哪邊

----

在存東西來看是鍊表比較好用，但是取資料的時候呢?

----

在取資料時陣列支援隨機訪問，也就意味著它可以跳著來查看資料

----

而鍊表則是支援順序訪問，也就意味著他只能一個一個慢慢找
這個原因在於鍊表處存時，是跳著的有洞就鑽，這使他須要依靠一個位置一個位置的去記憶串聯著，這讓他只能在1接著2接著3這樣下去尋找

----

所以在取用時，陣列比較好用

----

接下來正式進入選擇排序法

----

當你有一數字需要排序時，你要如何排序呢?

----

全部數字看過再從裡面挑最小的出來?

----

每次執行都會減少一個要讀取的數值，所以需要檢查的元素依序為：
n、n-1、n-2.....2、1

----

這樣需要 O(n x n x 1/2)的時間

----

給大家演示一下排序法的程式碼吧!

```python=
def findsmall(arr):
	small=arr[0]
	small_index=0
	for i in range(1,len(arr)):
		if arr[i]<small:
			small_index=i
	return small_index

def select(arr):
	newarr=[]
	for i in range(len(arr)):
		small=findsmall(arr)
		newarr.append(arr.pop(small)) 
        #這邊的small是上面的small_index，這邊沒有全域宣告
	return newarr

print(select([5,3,6,2,10,15]))

```

----

但這樣排序是最快的嗎?

----

當然不是，我們後面會提到更快的快速排序法

---

## 遞迴

----

Leigh Caldwell 曾說過「如果使用迴圈，程序性能可能更高；如果使用遞迴，程序可能更容易理解」

----

以算階層的程式來舉例迴圈跟遞迴吧!

----

迴圈
```python=
result=1
n=eval(input("input number"))
for i in range(1,n+1):
	result*=i
print(result)
```

----

遞迴
```python=
def fact(x):
	if x==1:
		return 1
	else:
		return x*fact(x-1)

print(fact(eval(input("input number"))))
```

----

接下來介紹基線條件和遞迴條件
當你要寫一個倒數的程式時，你用遞迴寫:

```python=
def countdown(i):
	print(i)
	countdown(i-1)
```

----

當你這樣寫時，你會發現這個程式不會停下來
所以你必須告訴她如何停止遞迴
正因為如此你必須在程式中給他條件

----

在遞迴的條件中分為基線條件和遞迴條件

基線條件：限制遞迴停止的條件
遞迴條件：遞迴該如何調用自己的條件

----

以剛剛的例子來看
```python
x==1
```
是基線條件
```python
x*fact(x-1)
```
是遞迴條件

----

還有一個重要的觀念是呼叫堆疊

----

簡單來說呼叫堆疊就是指當我們在處理一個程式時，裡面有著其他程式，我們就需要先暫停這個程式，然後去執行這個突然出現的程式，執行完後才能繼續執行原本暫停的程式

----

舉個例子:

```python=
def great(name):
    print("hello"+name+"?")
    great2(name)
    print("getting ready to say bye")
    bye()
def great2(name):
    print("how are you"+name+"?")
def bye():
    print("ok bye")
    
name=input("input")
great(name)
```

----

在上面的例子中，我們在執行great()時，會遇到great2()和bye()兩個function，我們便需要去暫停great()，去執行great2(0)然後繼續執行great()的print指令，再去執行bye()，然後才是程式結束

這樣是不是就像是一層一層疊上去然後再呼叫他呢?

---

# 快速排序

----

